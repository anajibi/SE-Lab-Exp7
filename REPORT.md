# <p style="text-align: center;">دانشگاه صنعتی شریف</br>دانشکده مهندسی کامپیوتر</br>آزمایشگاه مهندسی نرم افزار</p>

## اطلاعات تیم

### Ali Najibi, 98106123 </br>Alireza Honarvar, 98102551

## اطلاعات کلی 

در این آزمایش، قصد بررسی انوان مختلف باز آرایی ها با استفاده از ابزار های مختلف و پیاده سازی عملی آنها در کد برنامه خود را داریم.

## شرح

در ابتدا، همانطور که در ویدیوی آموزشی گفته شد، کد مربوط به
MiniJava 
را کلون کرده و در ریپازیتوری جدیدی که ساخته ایم پوش میکنیم، تا بتوانیم با استفاده از ابزار های برخط باز آرایی کد، 
کد را باز آرایی کنیم.

### دو مورد الگوی Facade

در ابتدا باید دو مورد الگوی Facade را در این کد اعمال کنیم، همانطور که 
میدانیم، این الگو اشاره به ساده سازی ارتباط کامپوننت های بیرونی که به اصطلاح به آنها Client نیز گفته میشود
و پکیج های دیگر که گاه میتوانند بسیار پیچیده باشند دارد.

1. اولین مورد اعمال این الگو درباره کلاس Scanner است، قبل از اعمال الگو، در کلاس Parser یک
Instance از نوع lexicalAnalyzer میسازیم و از آن برای اسکن کردن کد استفاده میکنیم، اما بعد از اعمال الگو،
یک Instance از نوع Scanner میسازیم و از آن برای اسکن کردن کد استفاده میکنیم، این کار باعث میشود که
کلاس Parser از کلاس Scanner کاملا مستقل شود و از آن به عنوان یک کامپوننت بیرونی استفاده کند.
2. همانند مورد بالا، این بار این کار را برای پکیج codeGenerator انجام میدهیم
به این شکل که یه کلاس جدید با نام CodeGeneratorFacade میسازیم و در آن یک Instance از نوع CodeGenerator
میسازیم و از آن برای تولید کد استفاده میکنیم، سپس در کلاس Parser از این کلاس برای تولید کد استفاده میکنیم.
علاوه بر آن برای اینکه کسی به کلاس CodeGenerator به صورت مستقیم و خارج از پکیج دسترسی نداشته باشد، این کلاس را از Public 
بودن خارج میکنیم.


### یک مورد الگوی State/Strategy یا استفاده از Polymorphism
برای اعمال این الگو، دقت کنید که در کلاس Action در متد ToString برا اساس تایپ یک سوئیچ کیس وجود دارد، برای از بین بردن این 
سوئیچ کیس، 3 زیرکلاس ساخته و کلاس Action را از نوع Abstract قرار میدهیم، در نتیجه، دیگر نیازی به 
این سوئیچ کیس نیست.

### یک مورد Separate Query from Modifier
در تابع getNextParameter در کلاس Method علاوه بر بازگرداندن یک پارامتر، index نیز یکی اضافه شده است، این یک مورد از جاهایی است که میتوانیم الگوی 
Separate Query from Modifier را اعمال کنیم، به این شکل که یک تابع دیگر تعریف میکنیم که index را افزایش دهد و این تابع را صدا میزنیم.

### 3 مورد از سایر بازآرایی ها
1. Self Encapsulate Field
در این باز آرایی، در کلاس Parser، استفاده ها از فیلد parseTable را
تغییر داده تا صرفا با setter و getter تغییر کند.
2. Polymorphism instead of condition
در کلاس Address در متد toString
با استفاده از type خروجی مشخص شده است، برای حل این مشکل، این کلاس را Abstract کرده و 3 کلاس دیگر تعریف میکنیم تا بجای این کلاس مورد استفاده قرار بگیرند و کد را اصلاح میکنیم
3. Self Encapsulate Field
 در کلاس SymbolTable برای فیلد mem این بازآرایی را انجام دادیم.


## پرسش ها
### سوال اول
-  کد تمیز: نوشتن کدی که به راحتی قابل خواندن، درک و نگهداری است، با پیروی از استانداردهای کدگذاری تعیین شده و بهترین شیوه ها. 
- بدهی فنی: عواقب استفاده از میانبرها یا ایجاد معاوضه در طول فرآیند توسعه نرم افزار، که منجر به کدهای با کیفیت پایین تر می شود که نیاز به تلاش های آینده برای اصلاح یا بهبود دارد.
- بوی بد: نشانه‌هایی از طراحی یا پیاده‌سازی ضعیف در کد که می‌تواند منجر به مشکلات نگهداری یا اشکالات شود، که اغلب نیاز به باز آرایی یا restructuring را نشان می‌دهد.
### سوال دوم
طبق
[لینک](https://refactoring.guru/refactoring/smells)
پنج دسته زیر برای بوی بد وجود دارد:
- Bloaters: اینها بوهای کدی هستند که نشان دهنده پیچیدگی بیش از حد یا تکرار غیرضروری است، مانند کلاس ها یا متدهای بزرگ، لیست پارامترهای طولانی یا کد اضافی.
- Object-Orientation Abusers:
  این بوها زمانی به وجود می آیند که کد اصول شی گرا را را نقض می کند. مانند وراثت نامناسب، یا استفاده نامناسب از وسواس اولیه (استفاده بیش از حد از انواع داده های primitive به جای ایجاد کلاس های اختصاصی).
- Change Preventers:
این بوها تغییر یا گسترش کد را دشوار میکنند، مانند tight coupling بین کلاس ها، shotgun surgery که به معنای نیاز به تغییر تعداد زیادی از قسمت های کد برای افزودن یا اصلاح یک بخش کوچک است.
- Dispensable
  این بوها شامل کدهای غیرضروری یا استفاده نشده، مانند کد مرده (کدی که دیگر اجرا نمی شود)، کدهای کامنت شده، یا متغیرها یا متدهای استفاده نشده است.
- Couplers
  این بوها نشان دهنده اتصال یا وابستگی بیش از حد بین کلاس ها، ماژول ها یا مؤلفه ها هستند، مانند feature envy
(کلاسی که بیش از حد از متد ها یا داده های کلاس دیگر استفاده می کند)، inappropriate intimacy (کلاس ها به شدت به درونیات یکدیگر متکی هستند) یا message chain (توالی طولانی فراخوانی متد بین اشیا).

### سوال سوم
- Lazy Class 
به کلاسی اطلاق میشود که کار کمی انجام میدهد و میتوانیم آن را با کلاس دیگری جایگزین کنیم.
این نوع کلاس در رده بوی بد Dispensable قرار میگیرد.
- دو بازآرایی پیشنهادی برای حذف این بوی بد عبارتند از:
1. Inline Class
2. Collapse Hierarchy
- گاهی اوقات این بوی بد به دلیل اهداف توسعه آینده ایجاد میشود، در این مورد، سعی کنید تعادلی بین وضوح و سادگی در کد ایجاد کرد.